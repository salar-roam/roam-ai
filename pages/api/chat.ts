// pages/api/chat.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { openai } from '../../lib/openai';
import { supabase } from '../../lib/supabase'; // Adjust path if necessary
import { getTownTimezone } from '../../lib/timezone-helpers'; // We will create this file

// --- Interfaces (Updated) ---
// Matches the structure the AI should extract and what the backend will process
interface ExtractedEventData {
  title?: string;
  description?: string;
  price_value?: number;
  price_text?: string;
  currency?: string;
  town?: string; // AI extracts town name, backend resolves to town_id
  host?: {
    name?: string;
    phone_whatsapp?: string;
    instagram?: string; // Added as per your hosts table
  };
  location?: {
    name?: string;
    address?: string;
    lat?: number;
    lng?: number;
    // mapsLink?: string; // REMOVED: No longer generated by AI or stored
  };
  tags?: string[];
  image_url?: string;
  links?: { url: string; text: string }[];
  recurrence_rule?: 'one-time' | 'weekly' | 'monthly' | 'daily' | string; // Strict types for recurrence
  is_on_demand?: boolean;
  occurrences?: {
    start_ts: string; // ISO 8601
    end_ts: string | null;
  }[];
}

interface EventCreationAIResponse {
  type: 'event_creation';
  status: 'incomplete' | 'confirmation_pending' | 'complete';
  event: ExtractedEventData; // AI's current understanding of the event
  follow_up_questions?: string[]; // AI generates these for 'incomplete' status
  confirmation_message?: string; // AI generates this for 'confirmation_pending' status
  user_facing_message?: string; // For final success message after 'complete'
}

interface SearchAIResponse {
  type: 'search';
  query: string;
  user_facing_message?: string; // Adding this property to match usage
}

interface GeneralMessageAIResponse {
  type: 'message';
  message: string;
}

// Combined AI response type
type AIResponse = EventCreationAIResponse | SearchAIResponse | GeneralMessageAIResponse;

// --- Helper for Timezone (NEW FILE - lib/timezone-helpers.ts) ---
// This file will remain as is, it's a simple helper.
// const getTownTimezone is imported from here.

// --- Main AI Prompt Generator (Updated Significantly - Removed Maps Link) ---
const getEventExtractionPrompt = (
  userInput: string,
  currentEventDraft: ExtractedEventData | null,
  conversationHistory: { text: string; sender: 'user' | 'ai' }[]
) => {
  const formattedHistory = JSON.stringify(conversationHistory, null, 2);
  const formattedDraft = JSON.stringify(currentEventDraft, null, 2);

  return `You are an AI assistant helping users create and search for events. Please process the following user input and respond according to the specified format.

Current Conversation History (for context, most recent last):
${formattedHistory}

Current Event Draft (important for merging new details):
${formattedDraft}

Now, based on the above conversation and draft, respond to the current user input: "${userInput}"`;
};

// --- Main API Handler Function (Updated to use new AI Response structure) ---
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  // Ensure frontend sends currentEventDraft and conversationHistory
  const { text: userInput, currentEventDraft, conversationHistory } = req.body;

  if (!userInput) {
    return res.status(400).json({ message: 'Missing user input' });
  }

  try {
    const fullPrompt = getEventExtractionPrompt(userInput, currentEventDraft, conversationHistory || []);

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125', // Consider 'gpt-4o' for better adherence to complex prompts
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that provides responses in JSON format.',
        },
        {
          role: 'system',
          content: fullPrompt,
        },
        {
          role: 'user',
          content: userInput,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1, // Lower temperature for more consistent JSON output
    });

    const rawResponse = completion.choices[0].message.content;
    console.log('Raw OpenAI Response:', rawResponse);

    if (!rawResponse) {
      return res.status(500).json({ message: 'OpenAI did not return a response.' });
    }

    let parsedResponse: AIResponse;
    try {
      parsedResponse = JSON.parse(rawResponse);
    } catch (jsonError) {
      console.error('Failed to parse OpenAI JSON response:', jsonError);
      return res.status(500).json({ message: 'Failed to parse AI response.', error: jsonError });
    }

    // Check if the response is a general message
    if (parsedResponse.type === 'message') {
      return res.status(200).json({ type: 'message', message: parsedResponse.message });
    }

    // If the response is not recognized, provide a more informative message
    return res.status(200).json({ type: 'message', message: 'I could not understand your request. Please try again.' });

  } catch (error: any) {
    console.error('OpenAI API error:', error);
    res.status(500).json({ message: 'Error processing your request with AI.', error: error.message });
  }
}