// pages/api/chat.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { openai } from '../../lib/openai';
import { supabase } from '../../lib/supabase'; // Adjust path if necessary
import { getTownTimezone } from '../../lib/timezone-helpers'; // We will create this file

// --- Interfaces (Updated) ---
// Matches the structure the AI should extract and what the backend will process
interface ExtractedEventData {
  title?: string;
  description?: string;
  price_value?: number;
  price_text?: string;
  currency?: string;
  town?: string; // AI extracts town name, backend resolves to town_id
  host?: {
    name?: string;
    phone_whatsapp?: string;
    instagram?: string; // Added as per your hosts table
  };
  location?: {
    name?: string;
    address?: string;
    lat?: number;
    lng?: number;
    // mapsLink?: string; // REMOVED: No longer generated by AI or stored
  };
  tags?: string[];
  image_url?: string;
  links?: { url: string; text: string }[];
  recurrence_rule?: 'one-time' | 'weekly' | 'monthly' | 'daily' | string; // Strict types for recurrence
  is_on_demand?: boolean;
  occurrences?: {
    start_ts: string; // ISO 8601
    end_ts: string | null;
  }[];
}

interface EventCreationAIResponse {
  type: 'event_creation';
  status: 'incomplete' | 'confirmation_pending' | 'complete';
  event: ExtractedEventData; // AI's current understanding of the event
  follow_up_questions?: string[]; // AI generates these for 'incomplete' status
  confirmation_message?: string; // AI generates this for 'confirmation_pending' status
  user_facing_message?: string; // For final success message after 'complete'
}

interface SearchAIResponse {
  type: 'search';
  query: string;
  user_facing_message?: string; // Adding this property to match usage
}

interface GeneralMessageAIResponse {
  type: 'message';
  message: string;
}

// Combined AI response type
type AIResponse = EventCreationAIResponse | SearchAIResponse | GeneralMessageAIResponse;

// --- Helper for Timezone (NEW FILE - lib/timezone-helpers.ts) ---
// This file will remain as is, it's a simple helper.
// const getTownTimezone is imported from here.

// --- Main AI Prompt Generator (Updated Significantly - Removed Maps Link) ---
const getEventExtractionPrompt = (
  userInput: string,
  currentEventDraft: ExtractedEventData | null,
  conversationHistory: { text: string; sender: 'user' | 'ai' }[]
) => {
  const formattedHistory = JSON.stringify(conversationHistory, null, 2);
  const formattedDraft = JSON.stringify(currentEventDraft, null, 2);

  return `You are an AI assistant helping users create and search for events. Please process the following user input and respond according to the specified format.

Current Conversation History (for context, most recent last):
${formattedHistory}

Current Event Draft (important for merging new details):
${formattedDraft}

Now, based on the above conversation and draft, respond to the current user input: "${userInput}"`;
};

// --- Main API Handler Function (Updated to use new AI Response structure) ---
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  // Ensure frontend sends currentEventDraft and conversationHistory
  const { text: userInput, currentEventDraft, conversationHistory } = req.body;

  if (!userInput) {
    return res.status(400).json({ message: 'Missing user input' });
  }

  try {
    const fullPrompt = getEventExtractionPrompt(userInput, currentEventDraft, conversationHistory || []);

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125', // Consider 'gpt-4o' for better adherence to complex prompts
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that provides responses in JSON format.',
        },
        {
          role: 'system',
          content: fullPrompt,
        },
        {
          role: 'user',
          content: userInput,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1, // Lower temperature for more consistent JSON output
    });

    const rawResponse = completion.choices[0].message.content;
    console.log('Raw OpenAI Response:', rawResponse);

    if (!rawResponse) {
      return res.status(500).json({ message: 'OpenAI did not return a response.' });
    }

    let parsedResponse: AIResponse;
    try {
      parsedResponse = JSON.parse(rawResponse);
    } catch (jsonError) {
      console.error('Failed to parse OpenAI JSON response:', jsonError);
      return res.status(500).json({ message: 'Failed to parse AI response.', error: jsonError });
    }

    // --- Handle AI Response based on its Type and Status ---
    if (parsedResponse.type === 'search') {
      const searchQuery = parsedResponse.query;
      if (!searchQuery) {
        return res.status(400).json({ message: 'Search query not provided by AI.' });
      }

      // --- PgVector Search Placeholder (More complex logic will go here) ---
      // For now, retaining basic keyword search.
      // This will be updated with actual embedding generation and vector search in a later step.
      const { data: events, error } = await supabase
        .from('events')
        .select(`
          id, title, description, price_value, price_text, currency, tags, image_url, links, recurrence_rule, is_on_demand,
          towns(name, tz),
          hosts(id, name, phone_whatsapp, instagram),
          locations(id, name, address, lat, lng),
          event_occurrences(start_ts, end_ts)
        `)
        .or(`title.ilike.%${searchQuery}%,description.ilike.%${searchQuery}%,tags.cs.{"${searchQuery}"},hosts.name.ilike.%${searchQuery}%,locations.name.ilike.%${searchQuery}%`)
        .limit(10);

      if (error) {
        console.error('Supabase search error:', error);
        return res.status(500).json({ message: 'Error searching events.', error: error.message });
      }

      // Flatten nested data for frontend display
      const formattedResults = events.map((event: any) => {
        // No mapsLink generation here as it's removed
        return {
          id: event.id,
          title: event.title,
          description: event.description || 'N/A',
          price_text: event.price_text || 'Free',
          host: event.hosts?.name || 'N/A',
          location: `${event.locations?.name || 'N/A'}, ${event.locations?.address || 'N/A'}`,
          occurrences: event.event_occurrences // Keep occurrences as array
        };
      });

      if (formattedResults && formattedResults.length > 0) {
        return res.status(200).json({ type: 'search_results', results: formattedResults });
      } else {
        return res.status(200).json({ type: 'search_results', message: parsedResponse.user_facing_message || 'No events found matching your search.' });
      }
    }

    if (parsedResponse.type === 'event_creation') {
      const eventData: ExtractedEventData = parsedResponse.event;
      const status = parsedResponse.status;
      const followUpQuestions: string[] = parsedResponse.follow_up_questions || [];
      const confirmationMessage: string | undefined = parsedResponse.confirmation_message;
      const userFacingMessage: string | undefined = parsedResponse.user_facing_message;

      if (status === 'incomplete' && followUpQuestions.length > 0) {
        return res.status(200).json({ type: 'follow_up', event: eventData, questions: followUpQuestions });
      }

      if (status === 'confirmation_pending' && confirmationMessage) {
        // Since mapsLink is removed, no placeholder replacement needed
        return res.status(200).json({ type: 'follow_up', event: eventData, questions: [confirmationMessage] });
      }

      if (status === 'complete' && eventData) {
        // This means the user has confirmed the event. Now, process and publish.
        // The actual `publish` API call needs to handle resolving IDs and inserting.
        return res.status(200).json({ type: 'event_ready', event: eventData, message: userFacingMessage || 'Event is ready for publishing!' });
      }

      // Fallback for unexpected AI response in event creation mode
      return res.status(200).json({ type: 'message', message: userFacingMessage || 'I\'m still processing your event details. Could you clarify?' });

    }

    // Default case if AI doesn't categorize correctly (type is 'message')
    if (parsedResponse.type === 'message' && parsedResponse.message) {
      return res.status(200).json({ type: 'message', message: parsedResponse.message });
    }

    // Generic fallback if all else fails
    return res.status(200).json({ type: 'message', message: 'I could not understand your request. Please try again.' });

  } catch (error: any) {
    console.error('OpenAI API error:', error);
    res.status(500).json({ message: 'Error processing your request with AI.', error: error.message });
  }
}