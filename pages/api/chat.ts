// pages/api/chat.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { openai } from '../../lib/openai';
import { supabase } from '../../lib/supabase'; // Adjust path if necessary
import { getTownTimezone } from '../../lib/timezone-helpers'; // We will create this file

// --- Interfaces (Updated) ---
// Matches the structure the AI should extract and what the backend will process
interface ExtractedEventData {
  title?: string;
  description?: string;
  price_value?: number;
  price_text?: string;
  currency?: string;
  town?: string; // AI extracts town name, backend resolves to town_id
  host?: {
    name?: string;
    phone_whatsapp?: string;
    instagram?: string; // Added as per your hosts table
  };
  location?: {
    name?: string;
    address?: string;
    lat?: number;
    lng?: number;
    // mapsLink?: string; // REMOVED: No longer generated by AI or stored
  };
  tags?: string[];
  image_url?: string;
  links?: { url: string; text: string }[];
  recurrence_rule?: 'one-time' | 'weekly' | 'monthly' | 'daily' | string; // Strict types for recurrence
  is_on_demand?: boolean;
  occurrences?: {
    start_ts: string; // ISO 8601
    end_ts: string | null;
  }[];
}

interface EventCreationAIResponse {
  type: 'event_creation';
  status: 'incomplete' | 'confirmation_pending' | 'complete';
  event: ExtractedEventData; // AI's current understanding of the event
  follow_up_questions?: string[]; // AI generates these for 'incomplete' status
  confirmation_message?: string; // AI generates this for 'confirmation_pending' status
  user_facing_message?: string; // For final success message after 'complete'
}

interface SearchAIResponse {
  type: 'search';
  query: string;
  user_facing_message?: string; // Adding this property to match usage
}

interface GeneralMessageAIResponse {
  type: 'message';
  message: string;
}

// Combined AI response type
type AIResponse = EventCreationAIResponse | SearchAIResponse | GeneralMessageAIResponse;

// --- Helper for Timezone (NEW FILE - lib/timezone-helpers.ts) ---
// This file will remain as is, it's a simple helper.
// const getTownTimezone is imported from here.

// --- Main AI Prompt Generator (Updated Significantly - Removed Maps Link) ---
const getEventExtractionPrompt = (
  userInput: string,
  currentEventDraft: ExtractedEventData | null,
  conversationHistory: { text: string; sender: 'user' | 'ai' }[]
) => {
  const formattedHistory = JSON.stringify(conversationHistory, null, 2);
  const formattedDraft = JSON.stringify(currentEventDraft, null, 2);

  return `You are an AI assistant helping users create and search for events. You must respond in JSON format with one of these types:

1. For event creation:
{
  "type": "event_creation",
  "status": "incomplete" | "confirmation_pending" | "complete",
  "event": {
    "title": string,
    "description": string,
    "price_value": number,
    "price_text": string,
    "currency": string,
    "town": string,
    "host": {
      "name": string,
      "phone_whatsapp": string,
      "instagram": string
    },
    "location": {
      "name": string,
      "address": string,
      "lat": number,
      "lng": number
    },
    "tags": string[],
    "image_url": string,
    "links": { "url": string, "text": string }[],
    "recurrence_rule": "one-time" | "weekly" | "monthly" | "daily",
    "is_on_demand": boolean,
    "occurrences": {
      "start_ts": string,
      "end_ts": string | null
    }[]
  },
  "follow_up_questions": string[],
  "confirmation_message": string,
  "user_facing_message": string
}

2. For search:
{
  "type": "search",
  "query": string,
  "user_facing_message": string
}

3. For general messages:
{
  "type": "message",
  "message": string
}

Current Conversation History (for context, most recent last):
${formattedHistory}

Current Event Draft (important for merging new details):
${formattedDraft}

Now, based on the above conversation and draft, respond to the current user input: "${userInput}"

Remember to always respond with a valid JSON object matching one of the above formats.`;
};

// --- Main API Handler Function (Updated to use new AI Response structure) ---
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  // Ensure frontend sends currentEventDraft and conversationHistory
  const { text: userInput, currentEventDraft, conversationHistory } = req.body;

  if (!userInput) {
    return res.status(400).json({ message: 'Missing user input' });
  }

  try {
    const fullPrompt = getEventExtractionPrompt(userInput, currentEventDraft, conversationHistory || []);

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo-0125', // Consider 'gpt-4o' for better adherence to complex prompts
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that provides responses in JSON format.',
        },
        {
          role: 'system',
          content: fullPrompt,
        },
        {
          role: 'user',
          content: userInput,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1, // Lower temperature for more consistent JSON output
    });

    const rawResponse = completion.choices[0].message.content;
    console.log('Raw OpenAI Response:', rawResponse);

    if (!rawResponse) {
      return res.status(500).json({ message: 'OpenAI did not return a response.' });
    }

    let parsedResponse: AIResponse;
    try {
      parsedResponse = JSON.parse(rawResponse);
      console.log('Parsed Response:', parsedResponse); // Add this line for debugging
    } catch (jsonError) {
      console.error('Failed to parse OpenAI JSON response:', jsonError);
      return res.status(500).json({ message: 'Failed to parse AI response.', error: jsonError });
    }

    // Handle different response types
    if (parsedResponse.type === 'event_creation') {
      const eventData: ExtractedEventData = parsedResponse.event;
      const status = parsedResponse.status;
      const followUpQuestions: string[] = parsedResponse.follow_up_questions || [];
      const confirmationMessage: string | undefined = parsedResponse.confirmation_message;
      const userFacingMessage: string | undefined = parsedResponse.user_facing_message;

      if (status === 'incomplete' && followUpQuestions.length > 0) {
        return res.status(200).json({ type: 'follow_up', event: eventData, questions: followUpQuestions });
      }

      if (status === 'confirmation_pending' && confirmationMessage) {
        return res.status(200).json({ type: 'follow_up', event: eventData, questions: [confirmationMessage] });
      }

      if (status === 'complete' && eventData) {
        return res.status(200).json({ type: 'event_ready', event: eventData, message: userFacingMessage || 'Event is ready for publishing!' });
      }
    }

    if (parsedResponse.type === 'search') {
      const searchQuery = parsedResponse.query;
      if (!searchQuery) {
        return res.status(400).json({ message: 'Search query not provided by AI.' });
      }

      // ... rest of search handling code ...
    }

    if (parsedResponse.type === 'message') {
      return res.status(200).json({ type: 'message', message: parsedResponse.message });
    }

    // If we get here, the response type wasn't recognized
    console.error('Unrecognized response type:', parsedResponse);
    return res.status(200).json({ 
      type: 'message', 
      message: parsedResponse.user_facing_message || 'I could not understand your request. Please try again.' 
    });

  } catch (error: any) {
    console.error('OpenAI API error:', error);
    res.status(500).json({ message: 'Error processing your request with AI.', error: error.message });
  }
}